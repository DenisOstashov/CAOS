## Письмо Дедушке Морозу

Прогресс не стоит на месте и Снегурочка по просьбе Деда Мороза написала программу, 
которая предобрабатывает входящие письма.

Программа на вход получает строки вида
`имя фамилия base64encoded_письмо`
и сортирует письма следующим образом:

1) Спам игнорируется
2) Для писем с очевидным и простым подарком выводит `имя фамилия подарок`
3) Для всех остальных писем выводит `имя фамилия Ручная проверка`, 
чтобы Дедушка Мороз самостоятельно прочитал письмо и выбрал подарок.

К сожалению, Снегурочка не знала что такое `-fstask-protector`, а также допустила пару незначительных ошибок.

Ваша задача воспользоваться ситуацией и получить новогодний подарок `250 баллов по АКОСу` любой ценой.

Напишите программу на python, 
которая сгенерирует необходимое письмо в поток вывода
в [base64encoded](https://en.wikipedia.org/wiki/Base64) формате.

Вам [доступен]() исходный текст программы и скомпилированный бинарь, который и будет запускаться на сервере.

Бинарный файл скомпилирован `g++ present_selector.cpp -O0 -fno-stack-protector -g -m32 -static -o new.out -z execstack`

Решение должно содержать не только ответ, но и явную генерацию ROP. 

Для вшитой инъекции приложите исходный код этой инъекции в виде многострочного комментария в решении.

Баллы за каждый тест начисляются независимо по 250 за тест. Штрафы за посылки отсутствуют.


## Полезности

[python base64](https://docs.python.org/3/library/base64.html#base64.b64encode)

[buffer overflow](https://en.wikipedia.org/wiki/Buffer_overflow)

[buffer overflow protection](https://en.wikipedia.org/wiki/Buffer_overflow_protection)

[ROP](https://en.wikipedia.org/wiki/Return-oriented_programming)

<br>
<details>
<summary>GDB</summary>

<em>b *0x8000</em> - поставить брейкпоинт по адресу 0x8000

<em>layout asm</em> - перейти в отображение по инструкциям

<em>Ctrl-x + a</em> - выйти из предыдущего

<em>frame 2</em> - перейти на второй фрейм колстека

<em>p *((void**)$esp + 4)</em> - вывести значение по адресу (верхушка стека + 4) в шестнадцатиричном формате

<em>s, n</em> - выполнить все до следующей строки исходного кода с учетом/без учета вызываемых функций

<em>si, ni</em> - аналогично, но по одной инструкции

</details>

<br>
<details>
<summary>objdump, readelf и прочее</summary>

<em>objdump -d present_selector</em> - декомпилирует программу

<em>grep "smth" -B 3 -A 1</em> - Позволяет вычленить вхождения определенной подстроки, захватив три строки до и две строки после

<em>readelf -l present_selector</em>

<em>objcopy -O binary -j .text present_selector text_section.bin</em> - вычленяет целиком байтовое представление .text секции в указанный файл

</details>


## Напутствие

Попробуйте решить задачку самостоятельно не используя спойлеров из плана решения. 

Я бы выделил три главных тезиса которые стоит помнить:

1) Внимательно наблюдай - между разными величинами бывает закономерность
2) Просто попробуй - вдруг сработает
3) Компилируй и изучай - можно посмотреть как что работает на своём тестовом коде


## План решения
<details>
<summary>0. Немного про c++ и классы</summary>

Любой метод, и в том числе конструктор и деструктор,- это функция, которая первым аргументом на вход принимает адрес этого объекта

Названия плюсовых функций и тем более методов кодируются особым образом.

Метод не проверяет валидность указателя, а лишь пишет или читает из нужных полей класса по смещению от указателя.

Следствие предыдущего - методы, которые не меняют поля класса можно вызвать от любого указателя.
</details>

<br>
<details>
<summary>1. С помощью buffer overflow заменить адрес возврата</summary>

Найти разницу между началом буфера и адресом возврата в текущем frame.

Постоянная ли эта величина? 

Постоянный ли адрес у buf? А если с/без gdb?

Как проверить что мы верно посчитали адрес с помощью функции debug_exit?
</details>

<br>
<details>
<summary>2. Получить множество годных для ROP инструкций</summary>

Для простоты давайте использовать по одной инструкции до ret. Такие инструкции будет проще объединить между собой.

В какой секции они должны находится? Статический или динамический адрес?

Рекомендуется использовать grep по objdump

</details>

<br>
<details>
<summary>3. С помощью ROP техники перейти на исполнение кода из буфера</summary>

План - поместить в eip адрес начала buf:

mov %esp, %some_reg

sub $чуток, %sub_reg

mov %sub_reg, $eip

<br>
<details>

<summary>Проблема: Среди годных для ROP инструкций нет ни одной подходящей под описание инструкций переноса %esp куда-либо</summary>

Заметим, что инструкции компилируются в определенный байткод, значение которого не меняется. 

ret это c3. Заметим, что такое число встречается и в середине других инструкций (например, e8 fe c3 0a 00 - call 80f96f0).

Значит количество подходящих инструкций для rop существенно больше чем мы нашли ранее. Но очень проблематично их все вывести.

Предполагая, что %some_reg это %eax - найдите mov %esp, %eax в секции .text
</details>

<br>
<details>
<summary>Проблема: надо как-то %some_reg поместить в %eip</summary>

С таким мы уже сталкивались. Кажется, достаточно запушить этот адрес на стек.
</details>

<br>
<details>
<summary>Проблема: return ""; - segfault при вызове конструктора std::string ещё до ROP</summary>

Что лежит прямо перед адресом возврата на стеке?

Что вызывает return ""; для этого объекта?

Что если вызвать это для экземпляра класса заполненного нулями?

Есть ли какой-то заранее известный адрес, заполненный нулями, размера sizeof(...), доступный на запись и чтение?
</details>

</details>

<br>
<details>
<summary>5. Сделать инъекцию простого кода, пройти тест 1</summary>

Тест 1 повторяет в точности тест из условия. В том числе имя и фамилия.

</details>

<br>
<details>
<summary>6. Восстановить все регистры и вернуть правильную std::string</summary>

std::string содержит полем адрес стандартного аллокатора. 

Этот аллокатор, к счастью, использует malloc и free и не хранит внетреннего состояния отдельно

</details>
